{
  "Deploys a new Edition contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployEdition",
    "body": [
      "const contractAddress = await sdk.deployer.deployEdition({",
      "  name: \"My Edition\",",
      "  primary_sale_recipient: \"your-address\",",
      "});"
    ],
    "description": "Deploys a new Edition contract | ContractDeployer contract"
  },
  "Deploys a new EditionDrop contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployEditionDrop",
    "body": [
      "const contractAddress = await sdk.deployer.deployEditionDrop({",
      "  name: \"My Edition Drop\",",
      "  primary_sale_recipient: \"your-address\",",
      "});"
    ],
    "description": "Deploys a new EditionDrop contract | ContractDeployer contract"
  },
  "Deploys a new Marketplace contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployMarketplace",
    "body": [
      "const contractAddress = await sdk.deployer.deployMarketplace({",
      "  name: \"My Marketplace\",",
      "  primary_sale_recipient: \"your-address\",",
      "});"
    ],
    "description": "Deploys a new Marketplace contract | ContractDeployer contract"
  },
  "Deploys a new Multiwrap contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployMultiwrap",
    "body": [
      "const contractAddress = await sdk.deployer.deployMultiwrap({",
      "  name: \"My Multiwrap\",",
      "});"
    ],
    "description": "Deploys a new Multiwrap contract | ContractDeployer contract"
  },
  "Deploys an NFT Collection contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployNFTCollection",
    "body": [
      "const contractAddress = await sdk.deployer.deployNFTCollection({",
      "  name: \"My Collection\",",
      "  primary_sale_recipient: \"your-address\",",
      "});"
    ],
    "description": "Deploys an NFT Collection contract | ContractDeployer contract"
  },
  "Deploys a new NFTDrop contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployNFTDrop",
    "body": [
      "const contractAddress = await sdk.deployer.deployNFTDrop({",
      "  name: \"My Drop\",",
      "  primary_sale_recipient: \"your-address\",",
      "});"
    ],
    "description": "Deploys a new NFTDrop contract | ContractDeployer contract"
  },
  "Deploys a new Pack contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployPack",
    "body": [
      "const contractAddress = await sdk.deployer.deployPack({",
      "  name: \"My Pack\",",
      "  primary_sale_recipient: \"your-address\",",
      "});"
    ],
    "description": "Deploys a new Pack contract | ContractDeployer contract"
  },
  "Deploys a new SignatureDrop contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeploySignatureDrop",
    "body": [
      "const contractAddress = await sdk.deployer.deploySignatureDrop({",
      "  name: \"My Signature Drop\",",
      "  primary_sale_recipient: \"your-address\",",
      "});"
    ],
    "description": "Deploys a new SignatureDrop contract | ContractDeployer contract"
  },
  "Deploys a new Split contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeploySplit",
    "body": [
      "const contractAddress = await sdk.deployer.deploySplit({",
      "  name: \"My Split\",",
      "  primary_sale_recipient: \"your-address\",",
      "  recipients: [",
      "   {",
      "     address: \"your-address\",",
      "     sharesBps: 80 * 100, // 80%",
      "   },",
      "   {",
      "     address: \"another-address\",",
      "     sharesBps: 20 * 100, // 20%",
      "   },",
      "  ],",
      "});"
    ],
    "description": "Deploys a new Split contract | ContractDeployer contract"
  },
  "Deploys a new Token contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployToken",
    "body": [
      "const contractAddress = await sdk.deployer.deployToken({",
      "  name: \"My Token\",",
      "  primary_sale_recipient: \"your-address\",",
      "});"
    ],
    "description": "Deploys a new Token contract | ContractDeployer contract"
  },
  "Deploys a new Token Drop contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployTokenDrop",
    "body": [
      "const contractAddress = await sdk.deployer.deployTokenDrop({",
      "  name: \"My Token Drop\",",
      "  primary_sale_recipient: \"your-address\",",
      "});"
    ],
    "description": "Deploys a new Token Drop contract | ContractDeployer contract"
  },
  "Deploys a new Vote contract | ContractDeployer contract": {
    "prefix": "contractdeployerDeployVote",
    "body": [
      "const contractAddress = await sdk.deployer.deployVote({",
      "  name: \"My Vote\",",
      "  primary_sale_recipient: \"your-address\",",
      "  voting_token_address: \"your-token-contract-address\",",
      "});"
    ],
    "description": "Deploys a new Vote contract | ContractDeployer contract"
  },
  "Subscribe to contract events | ContractEvents contract": {
    "prefix": "contracteventsAddEventListener",
    "body": [
      "contract.events.addEventListener(\"TokensMinted\", (event) => {",
      "  console.log(event);",
      "});"
    ],
    "description": "Subscribe to contract events | ContractEvents contract"
  },
  "Subscribe to transactions in this contract. | ContractEvents contract": {
    "prefix": "contracteventsAddTransactionListener",
    "body": [
      "contract.events.addTransactionListener((event) => {",
      "  console.log(event);",
      "}"
    ],
    "description": "Subscribe to transactions in this contract. | ContractEvents contract"
  },
  "Get All Events | ContractEvents contract": {
    "prefix": "contracteventsGetAllEvents",
    "body": [
      "// Optionally pass in filters to limit the blocks from which events are retrieved",
      "const filters = {",
      "  fromBlock: 0,",
      "  toBlock: 1000000,",
      "}",
      "const events = await contract.events.getAllEvents(filters);",
      "console.log(events[0].eventName);",
      "console.log(events[0].data);"
    ],
    "description": "Get All Events | ContractEvents contract"
  },
  "Get Events | ContractEvents contract": {
    "prefix": "contracteventsGetEvents",
    "body": [
      "// The name of the event to get logs for",
      "const eventName = \"Transfer\";",
      "// Optionally pass in filters to limit the blocks from which events are retrieved",
      "const filters = {",
      "  fromBlock: 0,",
      "  toBlock: 1000000,",
      "}",
      "const events = await contract.events.getEvents(eventName, filters);",
      "console.log(events[0].eventName);",
      "console.log(events[0].data);"
    ],
    "description": "Get Events | ContractEvents contract"
  },
  "Listen to all events emitted from this contract | ContractEvents contract": {
    "prefix": "contracteventsListenToAllEvents",
    "body": [
      "contract.events.listenToAllEvents((event) => {",
      "  console.log(event.eventName) // the name of the emitted event",
      "  console.log(event.data) // event payload",
      "}"
    ],
    "description": "Listen to all events emitted from this contract | ContractEvents contract"
  },
  "Remove all listeners on this contract | ContractEvents contract": {
    "prefix": "contracteventsRemoveAllListeners",
    "body": ["contract.events.removeAllListeners();"],
    "description": "Remove all listeners on this contract | ContractEvents contract"
  },
  "Remove an event listener from this contract | ContractEvents contract": {
    "prefix": "contracteventsRemoveEventListener",
    "body": [
      "contract.events.removeEventListener(\"TokensMinted\", (event) => {",
      "  console.log(event);",
      "});"
    ],
    "description": "Remove an event listener from this contract | ContractEvents contract"
  },
  "Remove a transaction listener | ContractEvents contract": {
    "prefix": "contracteventsRemoveTransactionListener",
    "body": [
      "contract.events.removeTransactionListener((event) => {",
      " console.log(event);",
      "}"
    ],
    "description": "Remove a transaction listener | ContractEvents contract"
  },
  "The next transaction executed will add/replace any overrides passed via the passed in hook. | ContractInterceptor contract": {
    "prefix": "contractinterceptorOverrideNextTransaction",
    "body": [
      "contract.interceptor.overrideNextTransaction(() => ({",
      "  gasLimit: 3000000,",
      "}));"
    ],
    "description": "The next transaction executed will add/replace any overrides passed via the passed in hook. | ContractInterceptor contract"
  },
  "Get the metadata of a contract | ContractMetadata contract": {
    "prefix": "contractmetadataGet",
    "body": ["const metadata = await contract.metadata.get();"],
    "description": "Get the metadata of a contract | ContractMetadata contract"
  },
  "Set the metadata of a contract | ContractMetadata contract": {
    "prefix": "contractmetadataSet",
    "body": [
      "await contract.metadata.set({",
      " name: \"My Contract\",",
      " description: \"My contract description\"",
      "})"
    ],
    "description": "Set the metadata of a contract | ContractMetadata contract"
  },
  "Update the metadata of a contract | ContractMetadata contract": {
    "prefix": "contractmetadataUpdate",
    "body": [
      "await contract.metadata.update({",
      "  name: \"My Contract\",",
      "  description: \"My contract description\"",
      "})"
    ],
    "description": "Update the metadata of a contract | ContractMetadata contract"
  },
  "Call this to get a list of addresses that are members of a specific role. | ContractRoles contract": {
    "prefix": "contractrolesGet",
    "body": ["const minterAddresses = await contract.roles.get(\"minter\");"],
    "description": "Call this to get a list of addresses that are members of a specific role. | ContractRoles contract"
  },
  "Call this to get get a list of addresses for all supported roles on the contract. | ContractRoles contract": {
    "prefix": "contractrolesGetAll",
    "body": ["const rolesAndMembers = await contract.roles.getAll();"],
    "description": "Call this to get get a list of addresses for all supported roles on the contract. | ContractRoles contract"
  },
  "Call this to grant a role to a specific address. | ContractRoles contract": {
    "prefix": "contractrolesGrant",
    "body": [
      "await contract.roles.grant(\"minter\", \"0x1234567890123456789012345678901234567890\");"
    ],
    "description": "Call this to grant a role to a specific address. | ContractRoles contract"
  },
  "Call this to revoke a role from a specific address. | ContractRoles contract": {
    "prefix": "contractrolesRevoke",
    "body": [
      "await contract.roles.revoke(\"minter\", \"0x1234567890123456789012345678901234567890\");"
    ],
    "description": "Call this to revoke a role from a specific address. | ContractRoles contract"
  },
  "Call this to OVERWRITE the list of addresses that are members of specific roles.Every role in the list will be overwritten with the new list of addresses provided with them. If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead. | ContractRoles contract": {
    "prefix": "contractrolesSetAll",
    "body": [
      "const minterAddresses = await contract.roles.get(\"minter\");",
      "await contract.roles.setAll({",
      " minter: []",
      "});",
      "console.log(await contract.roles.get(\"minter\")); // No matter what members had the role before, the new list will be set to []"
    ],
    "description": "Call this to OVERWRITE the list of addresses that are members of specific roles.Every role in the list will be overwritten with the new list of addresses provided with them. If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead. | ContractRoles contract"
  },
  "Create a batch of encrypted NFTs that can be revealed at a later time. | DelayedReveal contract": {
    "prefix": "delayedrevealCreateDelayedRevealBatch",
    "body": [
      "// the real NFTs, these will be encrypted until your reveal them!",
      "const realNFTs = [{",
      "  name: \"Common NFT #1\",",
      "  description: \"Common NFT, one of many.\",",
      "  image: fs.readFileSync(\"path/to/image.png\"),",
      "}, {",
      "  name: \"Super Rare NFT #2\",",
      "  description: \"You got a Super Rare NFT!\",",
      "  image: fs.readFileSync(\"path/to/image.png\"),",
      "}];",
      "// A placeholder NFT that people will get immediately in their wallet, until the reveal happens!",
      "const placeholderNFT = {",
      "  name: \"Hidden NFT\",",
      "  description: \"Will be revealed next week!\"",
      "};",
      "// Create and encrypt the NFTs",
      "await contract.revealer.createDelayedRevealBatch(",
      "  placeholderNFT,",
      "  realNFTs,",
      "  \"my secret password\",",
      ");",
      "// Whenever you're ready, reveal your NFTs at any time!",
      "const batchId = 0; // the batch to reveal",
      "await contract.revealer.reveal(batchId, \"my secret password\");"
    ],
    "description": "Create a batch of encrypted NFTs that can be revealed at a later time. | DelayedReveal contract"
  },
  "Gets the list of unrevealed NFT batches. | DelayedReveal contract": {
    "prefix": "delayedrevealGetBatchesToReveal",
    "body": ["const batches = await contract.revealer.getBatchesToReveal();"],
    "description": "Gets the list of unrevealed NFT batches. | DelayedReveal contract"
  },
  "Reveal a batch of hidden NFTs | DelayedReveal contract": {
    "prefix": "delayedrevealReveal",
    "body": [
      "// the batch to reveal",
      "const batchId = 0;",
      "// reveal the batch",
      "await contract.revealer.reveal(batchId, \"my secret password\");"
    ],
    "description": "Reveal a batch of hidden NFTs | DelayedReveal contract"
  },
  "Can Claim | DropClaimConditions contract": {
    "prefix": "dropclaimconditionsCanClaim",
    "body": [
      "// Quantity of tokens to check claimability of",
      "const quantity = 1;",
      "const canClaim = await contract.canClaim(quantity);"
    ],
    "description": "Can Claim | DropClaimConditions contract"
  },
  "Set public mint conditions | DropClaimConditions contract": {
    "prefix": "dropclaimconditionsSet",
    "body": [
      "const presaleStartTime = new Date();",
      "const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);",
      "",
      "// Optionally specify addresses that can claim",
      "const snapshots = ['0x...', '0x...']",
      "",
      "// Or alternatively, you can pass snapshots with the max number of NFTs each address can claim",
      "// const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]",
      "",
      "const claimConditions = [",
      "  {",
      "    startTime: presaleStartTime, // start the presale now",
      "    maxQuantity: 2, // limit how many mints for this presale",
      "    price: 0.01, // presale price",
      "    snapshot: snapshots, // limit minting to only certain addresses",
      "  },",
      "  {",
      "    startTime: publicSaleStartTime, // 24h after presale, start public sale",
      "    price: 0.08, // public sale price",
      "  }",
      "]);",
      "",
      "await dropContract.claimConditions.set(claimConditions);"
    ],
    "description": "Set public mint conditions | DropClaimConditions contract"
  },
  "Burn a specified amount of a NFT | Edition contract": {
    "prefix": "editionBurnTokens",
    "body": ["const result = await contract.burnTokens(tokenId, amount);"],
    "description": "Burn a specified amount of a NFT | Edition contract"
  },
  "Get All Minted NFTs | Edition contract": {
    "prefix": "editionGetAll",
    "body": ["const nfts = await contract.getAll();"],
    "description": "Get All Minted NFTs | Edition contract"
  },
  "Get Owned NFTs | Edition contract": {
    "prefix": "editionGetOwned",
    "body": [
      "// Address of the wallet to get the NFTs of",
      "const address = \"{{wallet_address}}\";",
      "const nfts = await contract.getOwned(address);"
    ],
    "description": "Get Owned NFTs | Edition contract"
  },
  "Mint Many NFTs with limited supplies | Edition contract": {
    "prefix": "editionMintBatchTo",
    "body": [
      "// Address of the wallet you want to mint the NFT to",
      "const toAddress = \"{{wallet_address}}\"",
      "",
      "// Custom metadata and supplies of your NFTs",
      "const metadataWithSupply = [{",
      "  supply: 50, // The number of this NFT you want to mint",
      "  metadata: {",
      "    name: \"Cool NFT #1\",",
      "    description: \"This is a cool NFT\",",
      "    image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file",
      "  },",
      "}, {",
      "  supply: 100,",
      "  metadata: {",
      "    name: \"Cool NFT #2\",",
      "    description: \"This is a cool NFT\",",
      "    image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file",
      "  },",
      "}];",
      "",
      "const tx = await contract.mintBatchTo(toAddress, metadataWithSupply);",
      "const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs",
      "const firstTokenId = tx[0].id; // token id of the first minted NFT",
      "const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT"
    ],
    "description": "Mint Many NFTs with limited supplies | Edition contract"
  },
  "Mint an NFT with a limited supply | Edition contract": {
    "prefix": "editionMintTo",
    "body": [
      "// Address of the wallet you want to mint the NFT to",
      "const toAddress = \"{{wallet_address}}\"",
      "",
      "// Custom metadata of the NFT, note that you can fully customize this metadata with other properties.",
      "const metadata = {",
      "  name: \"Cool NFT\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file",
      "}",
      "",
      "const metadataWithSupply = {",
      "  metadata,",
      "  supply: 1000, // The number of this NFT you want to mint",
      "}",
      "",
      "const tx = await contract.mintTo(toAddress, metadataWithSupply);",
      "const receipt = tx.receipt; // the transaction receipt",
      "const tokenId = tx.id; // the id of the NFT minted",
      "const nft = await tx.data(); // (optional) fetch details of minted NFT"
    ],
    "description": "Mint an NFT with a limited supply | Edition contract"
  },
  "Airdrop multiple NFTs | Edition contract": {
    "prefix": "editionAirdrop",
    "body": [
      "// The token ID of the NFT you want to airdrop",
      "const tokenId = \"0\";",
      "// Array of objects of addresses and quantities to airdrop NFTs to",
      "const addresses = [",
      " {",
      "   address: \"0x...\",",
      "   quantity: 2,",
      " },",
      " {",
      "  address: \"0x...\",",
      "   quantity: 3,",
      " },",
      "];",
      "await contract.airdrop(tokenId, addresses);",
      "",
      "// You can also pass an array of addresses, it will airdrop 1 NFT per address",
      "const tokenId = \"0\";",
      "const addresses = [",
      " \"0x...\", \"0x...\", \"0x...\",",
      "]",
      "await contract.airdrop(tokenId, addresses);"
    ],
    "description": "Airdrop multiple NFTs | Edition contract"
  },
  "Get NFT Balance | Edition contract": {
    "prefix": "editionBalanceOf",
    "body": [
      "// Address of the wallet to check NFT balance",
      "const walletAddress = \"{{wallet_address}}\";",
      "const tokenId = 0; // Id of the NFT to check",
      "const balance = await contract.balanceOf(walletAddress, tokenId);"
    ],
    "description": "Get NFT Balance | Edition contract"
  },
  "Get a single NFT Metadata | Edition contract": {
    "prefix": "editionGet",
    "body": ["const nft = await contract.get(\"0\");"],
    "description": "Get a single NFT Metadata | Edition contract"
  },
  "Transfer a single NFT | Edition contract": {
    "prefix": "editionTransfer",
    "body": [
      "// Address of the wallet you want to send the NFT to",
      "const toAddress = \"{{wallet_address}}\";",
      "const tokenId = \"0\"; // The token ID of the NFT you want to send",
      "const amount = 3; // How many copies of the NFTs to transfer",
      "await contract.transfer(toAddress, tokenId, amount);"
    ],
    "description": "Transfer a single NFT | Edition contract"
  },
  "Burn a specified amount of a NFT | EditionDrop contract": {
    "prefix": "editiondropBurnTokens",
    "body": ["const result = await contract.burnTokens(tokenId, amount);"],
    "description": "Burn a specified amount of a NFT | EditionDrop contract"
  },
  "Claim NFTs to a specific Wallet | EditionDrop contract": {
    "prefix": "editiondropClaimTo",
    "body": [
      "const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs",
      "const tokenId = 0; // the id of the NFT you want to claim",
      "const quantity = 1; // how many NFTs you want to claim",
      "",
      "const tx = await contract.claimTo(address, tokenId, quantity);",
      "const receipt = tx.receipt; // the transaction receipt"
    ],
    "description": "Claim NFTs to a specific Wallet | EditionDrop contract"
  },
  "Create a batch of NFTs to be claimed in the future | EditionDrop contract": {
    "prefix": "editiondropCreateBatch",
    "body": [
      "// Custom metadata of the NFTs to create",
      "const metadatas = [{",
      "  name: \"Cool NFT\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file",
      "}, {",
      "  name: \"Cool NFT\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/image.png\"),",
      "}];",
      "",
      "const results = await contract.createBatch(metadatas); // uploads and creates the NFTs on chain",
      "const firstTokenId = results[0].id; // token id of the first created NFT",
      "const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT"
    ],
    "description": "Create a batch of NFTs to be claimed in the future | EditionDrop contract"
  },
  "Get All Minted NFTs | EditionDrop contract": {
    "prefix": "editiondropGetAll",
    "body": ["const nfts = await contract.getAll();"],
    "description": "Get All Minted NFTs | EditionDrop contract"
  },
  "Get Owned NFTs | EditionDrop contract": {
    "prefix": "editiondropGetOwned",
    "body": [
      "// Address of the wallet to get the NFTs of",
      "const address = \"{{wallet_address}}\";",
      "const nfts = await contract.getOwned(address);"
    ],
    "description": "Get Owned NFTs | EditionDrop contract"
  },
  "Airdrop multiple NFTs | EditionDrop contract": {
    "prefix": "editiondropAirdrop",
    "body": [
      "// The token ID of the NFT you want to airdrop",
      "const tokenId = \"0\";",
      "// Array of objects of addresses and quantities to airdrop NFTs to",
      "const addresses = [",
      " {",
      "   address: \"0x...\",",
      "   quantity: 2,",
      " },",
      " {",
      "  address: \"0x...\",",
      "   quantity: 3,",
      " },",
      "];",
      "await contract.airdrop(tokenId, addresses);",
      "",
      "// You can also pass an array of addresses, it will airdrop 1 NFT per address",
      "const tokenId = \"0\";",
      "const addresses = [",
      " \"0x...\", \"0x...\", \"0x...\",",
      "]",
      "await contract.airdrop(tokenId, addresses);"
    ],
    "description": "Airdrop multiple NFTs | EditionDrop contract"
  },
  "Get NFT Balance | EditionDrop contract": {
    "prefix": "editiondropBalanceOf",
    "body": [
      "// Address of the wallet to check NFT balance",
      "const walletAddress = \"{{wallet_address}}\";",
      "const tokenId = 0; // Id of the NFT to check",
      "const balance = await contract.balanceOf(walletAddress, tokenId);"
    ],
    "description": "Get NFT Balance | EditionDrop contract"
  },
  "Get a single NFT Metadata | EditionDrop contract": {
    "prefix": "editiondropGet",
    "body": ["const nft = await contract.get(\"0\");"],
    "description": "Get a single NFT Metadata | EditionDrop contract"
  },
  "Transfer a single NFT | EditionDrop contract": {
    "prefix": "editiondropTransfer",
    "body": [
      "// Address of the wallet you want to send the NFT to",
      "const toAddress = \"{{wallet_address}}\";",
      "const tokenId = \"0\"; // The token ID of the NFT you want to send",
      "const amount = 3; // How many copies of the NFTs to transfer",
      "await contract.transfer(toAddress, tokenId, amount);"
    ],
    "description": "Transfer a single NFT | EditionDrop contract"
  },
  "Returns the current gas price in gwei | GasCostEstimator contract": {
    "prefix": "gascostestimatorCurrentGasPriceInGwei",
    "body": [
      "const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();"
    ],
    "description": "Returns the current gas price in gwei | GasCostEstimator contract"
  },
  "Estimates the cost of gas in native token of the current chain Pass in the same parameters as the contract's function. | GasCostEstimator contract": {
    "prefix": "gascostestimatorGasCostOf",
    "body": [
      "const costOfClaim = await nftDrop?.estimator.gasCostOf(\"claim\", [",
      "  \"0x...\", // receiver",
      "  1, // quantity",
      "  \"0x...\", // currency",
      "  1, // price per token",
      "  [], // proofs",
      "  1, // proof max quantity per transaction",
      "]);"
    ],
    "description": "Estimates the cost of gas in native token of the current chain Pass in the same parameters as the contract's function. | GasCostEstimator contract"
  },
  "Estimates the gas limit of a transaction Pass in the same parameters as the contract's function. | GasCostEstimator contract": {
    "prefix": "gascostestimatorGasLimitOf",
    "body": [
      "const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf(\"claim\", [",
      "  \"0x...\", // receiver",
      "  1, // quantity",
      "  \"0x...\", // currency",
      "  1, // price per token",
      "  [], // proofs",
      "  1, // proof max quantity per transaction",
      "]);"
    ],
    "description": "Estimates the gas limit of a transaction Pass in the same parameters as the contract's function. | GasCostEstimator contract"
  },
  "Purchase NFTs | Marketplace contract": {
    "prefix": "marketplaceBuyoutListing",
    "body": [
      "// The listing ID of the asset you want to buy",
      "const listingId = 0;",
      "// Quantity of the asset you want to buy",
      "const quantityDesired = 1;",
      "",
      "await contract.buyoutListing(listingId, quantityDesired);"
    ],
    "description": "Purchase NFTs | Marketplace contract"
  },
  "Get all active listings | Marketplace contract": {
    "prefix": "marketplaceGetActiveListings",
    "body": [
      "const listings = await contract.getActiveListings();",
      "const priceOfFirstActiveListing = listings[0].price;"
    ],
    "description": "Get all active listings | Marketplace contract"
  },
  "Get all the listings | Marketplace contract": {
    "prefix": "marketplaceGetAllListings",
    "body": [
      "const listings = await contract.getAllListings();",
      "const priceOfFirstListing = listings[0].price;"
    ],
    "description": "Get all the listings | Marketplace contract"
  },
  "Convenience function to get either a direct or auction listing | Marketplace contract": {
    "prefix": "marketplaceGetListing",
    "body": [
      "const listingId = 0;",
      "const listing = await contract.getListing(listingId);"
    ],
    "description": "Convenience function to get either a direct or auction listing | Marketplace contract"
  },
  "Set the Auction bid buffer | Marketplace contract": {
    "prefix": "marketplaceSetBidBufferBps",
    "body": [
      "// the bid buffer in basis points",
      "const bufferBps = 5_00; // 5%",
      "await contract.setBidBufferBps(bufferBps);"
    ],
    "description": "Set the Auction bid buffer | Marketplace contract"
  },
  "Set the Auction Time buffer: | Marketplace contract": {
    "prefix": "marketplaceSetTimeBufferInSeconds",
    "body": [
      "// the time buffer in seconds",
      "const bufferInSeconds = 60;",
      "await contract.setTimeBufferInSeconds(bufferInSeconds);"
    ],
    "description": "Set the Auction Time buffer: | Marketplace contract"
  },
  "Buyout Auction | MarketplaceAuction contract": {
    "prefix": "marketplaceauctionBuyoutListing",
    "body": [
      "// The listing ID of the asset you want to buy",
      "const listingId = 0;",
      "",
      "await contract.auction.buyoutListing(listingId);"
    ],
    "description": "Buyout Auction | MarketplaceAuction contract"
  },
  "Cancel Auction Listing | MarketplaceAuction contract": {
    "prefix": "marketplaceauctionCancelListing",
    "body": [
      "// The listing ID of the auction listing you want to cancel",
      "const listingId = \"0\";",
      "",
      "await contract.auction.cancelListing(listingId);"
    ],
    "description": "Cancel Auction Listing | MarketplaceAuction contract"
  },
  "Close the Auction | MarketplaceAuction contract": {
    "prefix": "marketplaceauctionCloseListing",
    "body": [
      "// The listing ID of the auction listing you want to close",
      "const listingId = \"0\";",
      "await contract.auction.closeListing(listingId);"
    ],
    "description": "Close the Auction | MarketplaceAuction contract"
  },
  "Create Auction | MarketplaceAuction contract": {
    "prefix": "marketplaceauctionCreateListing",
    "body": [
      "// Data of the auction you want to create",
      "const auction = {",
      "  // address of the contract the asset you want to list is on",
      "  assetContractAddress: \"0x...\",",
      "  // token ID of the asset you want to list",
      "  tokenId: \"0\",",
      " // when should the listing open up for offers",
      "  startTimestamp: new Date(),",
      "  // how long the listing will be open for",
      "  listingDurationInSeconds: 86400,",
      "  // how many of the asset you want to list",
      "  quantity: 1,",
      "  // address of the currency contract that will be used to pay for the listing",
      "  currencyContractAddress: NATIVE_TOKEN_ADDRESS,",
      "  // how much people would have to bid to instantly buy the asset",
      "  buyoutPricePerToken: \"10\",",
      "  // the minimum bid that will be accepted for the token",
      "  reservePricePerToken: \"1.5\",",
      "}",
      "",
      "const tx = await contract.auction.createListing(auction);",
      "const receipt = tx.receipt; // the transaction receipt",
      "const id = tx.id; // the id of the newly created listing"
    ],
    "description": "Create Auction | MarketplaceAuction contract"
  },
  "Get Auction Winner | MarketplaceAuction contract": {
    "prefix": "marketplaceauctionGetWinner",
    "body": [
      "// The listing ID of the auction that closed",
      "const listingId = 0;",
      "",
      "contract.auction.",
      "  .getWinner(listingId)",
      "  .then((auctionWinner) => console.log(auctionWinner))",
      "  .catch((err) => console.error(err));"
    ],
    "description": "Get Auction Winner | MarketplaceAuction contract"
  },
  "Get Highest Bid | MarketplaceAuction contract": {
    "prefix": "marketplaceauctionGetWinningBid",
    "body": [
      "// The listing ID of the auction that closed",
      "const listingId = 0;",
      "",
      "contract.auction.",
      "  .getWinningBid(listingId)",
      "  .then((offer) => console.log(offer))",
      "  .catch((err) => console.error(err));"
    ],
    "description": "Get Highest Bid | MarketplaceAuction contract"
  },
  "Bid On Auction | MarketplaceAuction contract": {
    "prefix": "marketplaceauctionMakeBid",
    "body": [
      "// The listing ID of the asset you want to bid on",
      "const listingId = 0;",
      "// The price you are willing to bid for a single token of the listing",
      "const pricePerToken = 1;",
      "",
      "await contract.auction.makeBid(listingId, pricePerToken);"
    ],
    "description": "Bid On Auction | MarketplaceAuction contract"
  },
  "Accept an offer on a direct listing | MarketplaceDirect contract": {
    "prefix": "marketplacedirectAcceptOffer",
    "body": [
      "// The listing ID of the asset you want to bid on",
      "const listingId = 0;",
      "// The price you are willing to bid for a single token of the listing",
      "const offeror = \"0x...\";",
      "",
      "await contract.direct.acceptOffer(listingId, offeror);"
    ],
    "description": "Accept an offer on a direct listing | MarketplaceDirect contract"
  },
  "Buy a Listing | MarketplaceDirect contract": {
    "prefix": "marketplacedirectBuyoutListing",
    "body": [
      "// The listing ID of the asset you want to buy",
      "const listingId = 0;",
      "// Quantity of the asset you want to buy",
      "const quantityDesired = 1;",
      "",
      "await contract.direct.buyoutListing(listingId, quantityDesired);"
    ],
    "description": "Buy a Listing | MarketplaceDirect contract"
  },
  "Cancel Direct Listing | MarketplaceDirect contract": {
    "prefix": "marketplacedirectCancelListing",
    "body": [
      "// The listing ID of the direct listing you want to cancel",
      "const listingId = \"0\";",
      "",
      "await contract.direct.cancelListing(listingId);"
    ],
    "description": "Cancel Direct Listing | MarketplaceDirect contract"
  },
  "Create Direct Listing | MarketplaceDirect contract": {
    "prefix": "marketplacedirectCreateListing",
    "body": [
      "// Data of the listing you want to create",
      "const listing = {",
      "  // address of the contract the asset you want to list is on",
      "  assetContractAddress: \"0x...\",",
      "  // token ID of the asset you want to list",
      "  tokenId: \"0\",",
      "  // when should the listing open up for offers",
      "  startTimestamp: new Date(),",
      "  // how long the listing will be open for",
      "  listingDurationInSeconds: 86400,",
      "  // how many of the asset you want to list",
      "  quantity: 1,",
      "  // address of the currency contract that will be used to pay for the listing",
      "  currencyContractAddress: NATIVE_TOKEN_ADDRESS,",
      "  // how much the asset will be sold for",
      "  buyoutPricePerToken: \"1.5\",",
      "}",
      "",
      "const tx = await contract.direct.createListing(listing);",
      "const receipt = tx.receipt; // the transaction receipt",
      "const id = tx.id; // the id of the newly created listing"
    ],
    "description": "Create Direct Listing | MarketplaceDirect contract"
  },
  "Make an offer for a Direct Listing | MarketplaceDirect contract": {
    "prefix": "marketplacedirectMakeOffer",
    "body": [
      "import { ChainId, NATIVE_TOKENS } from \"@thirdweb-dev/sdk\";",
      "",
      "// The listing ID of the asset you want to offer on",
      "const listingId = 0;",
      "// The price you are willing to offer per token",
      "const pricePerToken = 1;",
      "// The quantity of tokens you want to receive for this offer",
      "const quantity = 1;",
      "// The address of the currency you are making the offer in (must be ERC-20)",
      "const currencyContractAddress = NATIVE_TOKENS[ChainId.Rinkeby].wrapped.address",
      "",
      "await contract.direct.makeOffer(",
      "  listingId,",
      "  quantity,",
      "  currencyContractAddress,",
      "  pricePerToken",
      ");"
    ],
    "description": "Make an offer for a Direct Listing | MarketplaceDirect contract"
  },
  "Get All Wrapped Token Bundles | Multiwrap contract": {
    "prefix": "multiwrapGetAll",
    "body": [
      "const wrappedBundles = await contract.getAll();",
      "console.log(wrappedBundles);"
    ],
    "description": "Get All Wrapped Token Bundles | Multiwrap contract"
  },
  "Get the contents of a wrapped token bundle | Multiwrap contract": {
    "prefix": "multiwrapGetWrappedContents",
    "body": [
      "const contents = await contract.getWrappedContents(wrappedTokenId);",
      "console.log(contents.erc20Tokens);",
      "console.log(contents.erc721Tokens);",
      "console.log(contents.erc1155Tokens);"
    ],
    "description": "Get the contents of a wrapped token bundle | Multiwrap contract"
  },
  "Unwrap a wrapped token bundle, and retrieve its contents | Multiwrap contract": {
    "prefix": "multiwrapUnwrap",
    "body": ["await contract.unwrap(wrappedTokenId);"],
    "description": "Unwrap a wrapped token bundle, and retrieve its contents | Multiwrap contract"
  },
  "Wrap any number of ERC20/ERC721/ERC1155 tokens into a single wrapped token | Multiwrap contract": {
    "prefix": "multiwrapWrap",
    "body": [
      "const tx = await contract.wrap({",
      "  erc20Tokens: [{",
      "    contractAddress: \"0x...\",",
      "    quantity: \"0.8\"",
      "  }],",
      "  erc721Tokens: [{",
      "    contractAddress: \"0x...\",",
      "    tokenId: \"0\"",
      "  }],",
      "  erc1155Tokens: [{",
      "    contractAddress: \"0x...\",",
      "    tokenId: \"1\",",
      "    quantity: \"2\"",
      "  }]",
      "}, {",
      "    name: \"Wrapped bundle\",",
      "    description: \"This is a wrapped bundle of tokens and NFTs\",",
      "    image: \"ipfs://...\",",
      "});",
      "const receipt = tx.receipt(); // the transaction receipt",
      "const wrappedTokenId = tx.id; // the id of the wrapped token bundle"
    ],
    "description": "Wrap any number of ERC20/ERC721/ERC1155 tokens into a single wrapped token | Multiwrap contract"
  },
  "Get NFT Balance | Multiwrap contract": {
    "prefix": "multiwrapBalanceOf",
    "body": [
      "const walletAddress = \"{{wallet_address}}\";",
      "const balance = await contract.nft.balanceOf(walletAddress);",
      "console.log(balance);"
    ],
    "description": "Get NFT Balance | Multiwrap contract"
  },
  "Get a single NFT Metadata | Multiwrap contract": {
    "prefix": "multiwrapGet",
    "body": [
      "const tokenId = 0;",
      "const nft = await contract.nft.get(tokenId);"
    ],
    "description": "Get a single NFT Metadata | Multiwrap contract"
  },
  "Transfer a single NFT | Multiwrap contract": {
    "prefix": "multiwrapTransfer",
    "body": [
      "const walletAddress = \"{{wallet_address}}\";",
      "const tokenId = 0;",
      "await contract.nft.transfer(walletAddress, tokenId);"
    ],
    "description": "Transfer a single NFT | Multiwrap contract"
  },
  "Burn a single NFT | NFTCollection contract": {
    "prefix": "nftcollectionBurnToken",
    "body": ["const result = await contract.burnToken(tokenId);"],
    "description": "Burn a single NFT | NFTCollection contract"
  },
  "Get All Minted NFTs | NFTCollection contract": {
    "prefix": "nftcollectionGetAll",
    "body": ["const nfts = await contract.getAll();", "console.log(nfts);"],
    "description": "Get All Minted NFTs | NFTCollection contract"
  },
  "Get Owned NFTs | NFTCollection contract": {
    "prefix": "nftcollectionGetOwned",
    "body": [
      "// Address of the wallet to get the NFTs of",
      "const address = \"{{wallet_address}}\";",
      "const nfts = await contract.getOwned(address);",
      "console.log(nfts);"
    ],
    "description": "Get Owned NFTs | NFTCollection contract"
  },
  "Mint Many unique NFTs | NFTCollection contract": {
    "prefix": "nftcollectionMintBatchTo",
    "body": [
      "// Address of the wallet you want to mint the NFT to",
      "const walletAddress = \"{{wallet_address}}\";",
      "",
      "// Custom metadata of the NFTs you want to mint.",
      "const metadatas = [{",
      "  name: \"Cool NFT #1\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file",
      "}, {",
      "  name: \"Cool NFT #2\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/other/image.png\"),",
      "}];",
      "",
      "const tx = await contract.mintBatchTo(walletAddress, metadatas);",
      "const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs",
      "const firstTokenId = tx[0].id; // token id of the first minted NFT",
      "const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT"
    ],
    "description": "Mint Many unique NFTs | NFTCollection contract"
  },
  "Mint a unique NFT | NFTCollection contract": {
    "prefix": "nftcollectionMintTo",
    "body": [
      "// Address of the wallet you want to mint the NFT to",
      "const walletAddress = \"{{wallet_address}}\";",
      "",
      "// Custom metadata of the NFT, note that you can fully customize this metadata with other properties.",
      "const metadata = {",
      "  name: \"Cool NFT\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file",
      "};",
      "",
      "const tx = await contract.mintTo(walletAddress, metadata);",
      "const receipt = tx.receipt; // the transaction receipt",
      "const tokenId = tx.id; // the id of the NFT minted",
      "const nft = await tx.data(); // (optional) fetch details of minted NFT"
    ],
    "description": "Mint a unique NFT | NFTCollection contract"
  },
  "Get NFT Balance | NFTCollection contract": {
    "prefix": "nftcollectionBalanceOf",
    "body": [
      "const walletAddress = \"{{wallet_address}}\";",
      "const balance = await contract.nft.balanceOf(walletAddress);",
      "console.log(balance);"
    ],
    "description": "Get NFT Balance | NFTCollection contract"
  },
  "Get a single NFT Metadata | NFTCollection contract": {
    "prefix": "nftcollectionGet",
    "body": [
      "const tokenId = 0;",
      "const nft = await contract.nft.get(tokenId);"
    ],
    "description": "Get a single NFT Metadata | NFTCollection contract"
  },
  "Transfer a single NFT | NFTCollection contract": {
    "prefix": "nftcollectionTransfer",
    "body": [
      "const walletAddress = \"{{wallet_address}}\";",
      "const tokenId = 0;",
      "await contract.nft.transfer(walletAddress, tokenId);"
    ],
    "description": "Transfer a single NFT | NFTCollection contract"
  },
  "Burn a single NFT | NFTDrop contract": {
    "prefix": "nftdropBurnToken",
    "body": ["const result = await contract.burnToken(tokenId);"],
    "description": "Burn a single NFT | NFTDrop contract"
  },
  "Claim unique NFTs to a specific Wallet | NFTDrop contract": {
    "prefix": "nftdropClaimTo",
    "body": [
      "const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs",
      "const quantity = 1; // how many unique NFTs you want to claim",
      "",
      "const tx = await contract.claimTo(address, quantity);",
      "const receipt = tx.receipt; // the transaction receipt",
      "const claimedTokenId = tx.id; // the id of the NFT claimed",
      "const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata"
    ],
    "description": "Claim unique NFTs to a specific Wallet | NFTDrop contract"
  },
  "Create a batch of unique NFTs to be claimed in the future | NFTDrop contract": {
    "prefix": "nftdropCreateBatch",
    "body": [
      "// Custom metadata of the NFTs to create",
      "const metadatas = [{",
      "  name: \"Cool NFT\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file",
      "}, {",
      "  name: \"Cool NFT\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/image.png\"),",
      "}];",
      "",
      "const results = await contract.createBatch(metadatas); // uploads and creates the NFTs on chain",
      "const firstTokenId = results[0].id; // token id of the first created NFT",
      "const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT"
    ],
    "description": "Create a batch of unique NFTs to be claimed in the future | NFTDrop contract"
  },
  "Get All Minted NFTs | NFTDrop contract": {
    "prefix": "nftdropGetAll",
    "body": ["const nfts = await contract.getAll();", "console.log(nfts);"],
    "description": "Get All Minted NFTs | NFTDrop contract"
  },
  "Get All Claimed NFTs | NFTDrop contract": {
    "prefix": "nftdropGetAllClaimed",
    "body": [
      "const claimedNFTs = await contract.getAllClaimed();",
      "const firstOwner = claimedNFTs[0].owner;"
    ],
    "description": "Get All Claimed NFTs | NFTDrop contract"
  },
  "Get All Unclaimed NFTs | NFTDrop contract": {
    "prefix": "nftdropGetAllUnclaimed",
    "body": [
      "const unclaimedNFTs = await contract.getAllUnclaimed();",
      "const firstUnclaimedNFT = unclaimedNFTs[0].name;"
    ],
    "description": "Get All Unclaimed NFTs | NFTDrop contract"
  },
  "Get Owned NFTs | NFTDrop contract": {
    "prefix": "nftdropGetOwned",
    "body": [
      "// Address of the wallet to get the NFTs of",
      "const address = \"{{wallet_address}}\";",
      "const nfts = await contract.getOwned(address);",
      "console.log(nfts);"
    ],
    "description": "Get Owned NFTs | NFTDrop contract"
  },
  "Get the claimed supply | NFTDrop contract": {
    "prefix": "nftdropTotalClaimedSupply",
    "body": [
      "const claimedNFTCount = await contract.totalClaimedSupply();",
      "console.log(`NFTs claimed so far: ${claimedNFTCount}`);"
    ],
    "description": "Get the claimed supply | NFTDrop contract"
  },
  "Get the unclaimed supply | NFTDrop contract": {
    "prefix": "nftdropTotalUnclaimedSupply",
    "body": [
      "const unclaimedNFTCount = await contract.totalUnclaimedSupply();",
      "console.log(`NFTs left to claim: ${unclaimedNFTCount}`);"
    ],
    "description": "Get the unclaimed supply | NFTDrop contract"
  },
  "Get NFT Balance | NFTDrop contract": {
    "prefix": "nftdropBalanceOf",
    "body": [
      "const walletAddress = \"{{wallet_address}}\";",
      "const balance = await contract.nft.balanceOf(walletAddress);",
      "console.log(balance);"
    ],
    "description": "Get NFT Balance | NFTDrop contract"
  },
  "Get a single NFT Metadata | NFTDrop contract": {
    "prefix": "nftdropGet",
    "body": [
      "const tokenId = 0;",
      "const nft = await contract.nft.get(tokenId);"
    ],
    "description": "Get a single NFT Metadata | NFTDrop contract"
  },
  "Transfer a single NFT | NFTDrop contract": {
    "prefix": "nftdropTransfer",
    "body": [
      "const walletAddress = \"{{wallet_address}}\";",
      "const tokenId = 0;",
      "await contract.nft.transfer(walletAddress, tokenId);"
    ],
    "description": "Transfer a single NFT | NFTDrop contract"
  },
  "Create Pack | Pack contract": {
    "prefix": "packCreate",
    "body": [
      "const pack = {",
      "  // The metadata for the pack NFT itself",
      "  packMetadata: {",
      "    name: \"My Pack\",",
      "    description: \"This is a new pack\",",
      "    image: \"ipfs://...\",",
      "  },",
      "  // ERC20 rewards to be included in the pack",
      "  erc20Rewards: [",
      "    {",
      "      assetContract: \"0x...\",",
      "      quantityPerReward: 5,",
      "      quantity: 100,",
      "      totalRewards: 20,",
      "    }",
      "  ],",
      "  // ERC721 rewards to be included in the pack",
      "  erc721Rewards: [",
      "    {",
      "      assetContract: \"0x...\",",
      "      tokenId: 0,",
      "    }",
      "  ],",
      "  // ERC1155 rewards to be included in the pack",
      "  erc1155Rewards: [",
      "    {",
      "      assetContract: \"0x...\",",
      "      tokenId: 0,",
      "      quantityPerReward: 1,",
      "      totalRewards: 100,",
      "    }",
      "  ],",
      "  openStartTime: new Date(), // the date that packs can start to be opened, defaults to now",
      "  rewardsPerPack: 1, // the number of rewards in each pack, defaults to 1",
      "}",
      "",
      "const tx = await contract.create(pack);"
    ],
    "description": "Create Pack | Pack contract"
  },
  "Create Pack To Wallet | Pack contract": {
    "prefix": "packCreateTo",
    "body": [
      "const pack = {",
      "  // The metadata for the pack NFT itself",
      "  packMetadata: {",
      "    name: \"My Pack\",",
      "    description: \"This is a new pack\",",
      "    image: \"ipfs://...\",",
      "  },",
      "  // ERC20 rewards to be included in the pack",
      "  erc20Rewards: [",
      "    {",
      "      assetContract: \"0x...\",",
      "      quantityPerReward: 5,",
      "      quantity: 100,",
      "      totalRewards: 20,",
      "    }",
      "  ],",
      "  // ERC721 rewards to be included in the pack",
      "  erc721Rewards: [",
      "    {",
      "      assetContract: \"0x...\",",
      "      tokenId: 0,",
      "    }",
      "  ],",
      "  // ERC1155 rewards to be included in the pack",
      "  erc1155Rewards: [",
      "    {",
      "      assetContract: \"0x...\",",
      "      tokenId: 0,",
      "      quantityPerReward: 1,",
      "      totalRewards: 100,",
      "    }",
      "  ],",
      "  openStartTime: new Date(), // the date that packs can start to be opened, defaults to now",
      "  rewardsPerPack: 1, // the number of rewards in each pack, defaults to 1",
      "}",
      "",
      "const tx = await contract.createTo(\"0x...\", pack);"
    ],
    "description": "Create Pack To Wallet | Pack contract"
  },
  "Get All Packs | Pack contract": {
    "prefix": "packGetAll",
    "body": ["const packs = await contract.getAll();", "console.log(packs;"],
    "description": "Get All Packs | Pack contract"
  },
  "Get Owned Packs | Pack contract": {
    "prefix": "packGetOwned",
    "body": [
      "// Address of the wallet to get the packs of",
      "const address = \"{{wallet_address}}\";",
      "const packss = await contract.getOwned(address);"
    ],
    "description": "Get Owned Packs | Pack contract"
  },
  "Get Pack Contents | Pack contract": {
    "prefix": "packGetPackContents",
    "body": [
      "const packId = 0;",
      "const contents = await contract.getPackContents(packId);",
      "console.log(contents.erc20Rewards);",
      "console.log(contents.erc721Rewards);",
      "console.log(contents.erc1155Rewards);"
    ],
    "description": "Get Pack Contents | Pack contract"
  },
  "Open Pack | Pack contract": {
    "prefix": "packOpen",
    "body": [
      "const tokenId = 0",
      "const amount = 1",
      "const tx = await contract.open(tokenId, amount);"
    ],
    "description": "Open Pack | Pack contract"
  },
  "Airdrop multiple NFTs | Pack contract": {
    "prefix": "packAirdrop",
    "body": [
      "// The token ID of the NFT you want to airdrop",
      "const tokenId = \"0\";",
      "// Array of objects of addresses and quantities to airdrop NFTs to",
      "const addresses = [",
      " {",
      "   address: \"0x...\",",
      "   quantity: 2,",
      " },",
      " {",
      "  address: \"0x...\",",
      "   quantity: 3,",
      " },",
      "];",
      "await contract.airdrop(tokenId, addresses);",
      "",
      "// You can also pass an array of addresses, it will airdrop 1 NFT per address",
      "const tokenId = \"0\";",
      "const addresses = [",
      " \"0x...\", \"0x...\", \"0x...\",",
      "]",
      "await contract.airdrop(tokenId, addresses);"
    ],
    "description": "Airdrop multiple NFTs | Pack contract"
  },
  "Get NFT Balance | Pack contract": {
    "prefix": "packBalanceOf",
    "body": [
      "// Address of the wallet to check NFT balance",
      "const walletAddress = \"{{wallet_address}}\";",
      "const tokenId = 0; // Id of the NFT to check",
      "const balance = await contract.balanceOf(walletAddress, tokenId);"
    ],
    "description": "Get NFT Balance | Pack contract"
  },
  "Get a single NFT Metadata | Pack contract": {
    "prefix": "packGet",
    "body": ["const nft = await contract.get(\"0\");"],
    "description": "Get a single NFT Metadata | Pack contract"
  },
  "Transfer a single NFT | Pack contract": {
    "prefix": "packTransfer",
    "body": [
      "// Address of the wallet you want to send the NFT to",
      "const toAddress = \"{{wallet_address}}\";",
      "const tokenId = \"0\"; // The token ID of the NFT you want to send",
      "const amount = 3; // How many copies of the NFTs to transfer",
      "await contract.transfer(toAddress, tokenId, amount);"
    ],
    "description": "Transfer a single NFT | Pack contract"
  },
  "Burn a single NFT | SignatureDrop contract": {
    "prefix": "signaturedropBurnToken",
    "body": ["const result = await contract.burnToken(tokenId);"],
    "description": "Burn a single NFT | SignatureDrop contract"
  },
  "Claim unique NFTs to a specific Wallet | SignatureDrop contract": {
    "prefix": "signaturedropClaimTo",
    "body": [
      "const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs",
      "const quantity = 1; // how many unique NFTs you want to claim",
      "",
      "const tx = await contract.claimTo(address, quantity);",
      "const receipt = tx.receipt; // the transaction receipt",
      "const claimedTokenId = tx.id; // the id of the NFT claimed",
      "const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata"
    ],
    "description": "Claim unique NFTs to a specific Wallet | SignatureDrop contract"
  },
  "Create a batch of unique NFTs to be claimed in the future | SignatureDrop contract": {
    "prefix": "signaturedropCreateBatch",
    "body": [
      "// Custom metadata of the NFTs to create",
      "const metadatas = [{",
      "  name: \"Cool NFT\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file",
      "}, {",
      "  name: \"Cool NFT\",",
      "  description: \"This is a cool NFT\",",
      "  image: fs.readFileSync(\"path/to/image.png\"),",
      "}];",
      "",
      "const results = await contract.createBatch(metadatas); // uploads and creates the NFTs on chain",
      "const firstTokenId = results[0].id; // token id of the first created NFT",
      "const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT"
    ],
    "description": "Create a batch of unique NFTs to be claimed in the future | SignatureDrop contract"
  },
  "Get All Minted NFTs | SignatureDrop contract": {
    "prefix": "signaturedropGetAll",
    "body": ["const nfts = await contract.getAll();", "console.log(nfts);"],
    "description": "Get All Minted NFTs | SignatureDrop contract"
  },
  "Get All Claimed NFTs | SignatureDrop contract": {
    "prefix": "signaturedropGetAllClaimed",
    "body": [
      "const claimedNFTs = await contract.getAllClaimed();",
      "const firstOwner = claimedNFTs[0].owner;"
    ],
    "description": "Get All Claimed NFTs | SignatureDrop contract"
  },
  "Get All Unclaimed NFTs | SignatureDrop contract": {
    "prefix": "signaturedropGetAllUnclaimed",
    "body": [
      "const unclaimedNFTs = await contract.getAllUnclaimed();",
      "const firstUnclaimedNFT = unclaimedNFTs[0].name;"
    ],
    "description": "Get All Unclaimed NFTs | SignatureDrop contract"
  },
  "Get Owned NFTs | SignatureDrop contract": {
    "prefix": "signaturedropGetOwned",
    "body": [
      "// Address of the wallet to get the NFTs of",
      "const address = \"{{wallet_address}}\";",
      "const nfts = await contract.getOwned(address);",
      "console.log(nfts);"
    ],
    "description": "Get Owned NFTs | SignatureDrop contract"
  },
  "Get the claimed supply | SignatureDrop contract": {
    "prefix": "signaturedropTotalClaimedSupply",
    "body": [
      "const claimedNFTCount = await contract.totalClaimedSupply();",
      "console.log(`NFTs claimed so far: ${claimedNFTCount}`);"
    ],
    "description": "Get the claimed supply | SignatureDrop contract"
  },
  "Get the unclaimed supply | SignatureDrop contract": {
    "prefix": "signaturedropTotalUnclaimedSupply",
    "body": [
      "const unclaimedNFTCount = await contract.totalUnclaimedSupply();",
      "console.log(`NFTs left to claim: ${unclaimedNFTCount}`);"
    ],
    "description": "Get the unclaimed supply | SignatureDrop contract"
  },
  "Get NFT Balance | SignatureDrop contract": {
    "prefix": "signaturedropBalanceOf",
    "body": [
      "const walletAddress = \"{{wallet_address}}\";",
      "const balance = await contract.nft.balanceOf(walletAddress);",
      "console.log(balance);"
    ],
    "description": "Get NFT Balance | SignatureDrop contract"
  },
  "Get a single NFT Metadata | SignatureDrop contract": {
    "prefix": "signaturedropGet",
    "body": [
      "const tokenId = 0;",
      "const nft = await contract.nft.get(tokenId);"
    ],
    "description": "Get a single NFT Metadata | SignatureDrop contract"
  },
  "Transfer a single NFT | SignatureDrop contract": {
    "prefix": "signaturedropTransfer",
    "body": [
      "const walletAddress = \"{{wallet_address}}\";",
      "const tokenId = 0;",
      "await contract.nft.transfer(walletAddress, tokenId);"
    ],
    "description": "Transfer a single NFT | SignatureDrop contract"
  },
  "Call any function on this contract | SmartContract contract": {
    "prefix": "smartcontractCall",
    "body": [
      "// read functions will return the data from the contract",
      "const myValue = await contract.call(\"myReadFunction\");",
      "console.log(myValue);",
      "",
      "// write functions will return the transaction receipt",
      "const tx = await contract.call(\"myWriteFunction\", arg1, arg2);",
      "const receipt = tx.receipt;",
      "",
      "// Optionally override transaction options",
      "await contract.call(\"myWriteFunction\", arg1, arg2, {",
      " gasLimit: 1000000, // override default gas limit",
      " value: ethers.utils.parseEther(\"0.1\"), // send 0.1 ether with the contract call",
      "};"
    ],
    "description": "Call any function on this contract | SmartContract contract"
  },
  "Get Funds owed to a particular wallet | Split contract": {
    "prefix": "splitBalanceOf",
    "body": [
      "// The address to check the funds of",
      "const address = \"{{wallet_address}}\";",
      "const funds = await contract.balanceOf(address);",
      "console.log(funds);"
    ],
    "description": "Get Funds owed to a particular wallet | Split contract"
  },
  "Get non-native Token Funds owed to a particular wallet | Split contract": {
    "prefix": "splitBalanceOfToken",
    "body": [
      "// The address to check the funds of",
      "const address = \"{{wallet_address}}\";",
      "// The address of the currency to check the contracts funds of",
      "const tokenAddress = \"0x...\"",
      "const funds = await contract.balanceOfToken(address, tokenAddress);",
      "console.log(funds);"
    ],
    "description": "Get non-native Token Funds owed to a particular wallet | Split contract"
  },
  "Distribute Funds | Split contract": {
    "prefix": "splitDistribute",
    "body": ["await contract.distribute();"],
    "description": "Distribute Funds | Split contract"
  },
  "Distribute Funds | Split contract": {
    "prefix": "splitDistributeToken",
    "body": [
      "// The address of the currency to distribute funds",
      "const tokenAddress = \"0x...\"",
      "await contract.distributeToken(tokenAddress);"
    ],
    "description": "Distribute Funds | Split contract"
  },
  "Get Recipients of this splits contract | Split contract": {
    "prefix": "splitGetAllRecipients",
    "body": [
      "const recipients = await contract.getAllRecipients();",
      "console.log(recipients);"
    ],
    "description": "Get Recipients of this splits contract | Split contract"
  },
  "Withdraw Funds | Split contract": {
    "prefix": "splitWithdraw",
    "body": [
      "// the wallet address that wants to withdraw their funds",
      "const walletAddress = \"{{wallet_address}}\"",
      "await contract.withdraw(walletAddress);"
    ],
    "description": "Withdraw Funds | Split contract"
  },
  "Get an instance of the thirdweb SDK based on a private key. | ThirdwebSDK contract": {
    "prefix": "thirdwebsdkFromPrivateKey",
    "body": [
      "const sdk = ThirdwebSDK.fromPrivateKey(\"SecretPrivateKey\", \"mainnet\");"
    ],
    "description": "Get an instance of the thirdweb SDK based on a private key. | ThirdwebSDK contract"
  },
  "Get an instance of the thirdweb SDK based on an existing ethers signer | ThirdwebSDK contract": {
    "prefix": "thirdwebsdkFromSigner",
    "body": [
      "// get a signer from somewhere (createRandom is being used purely for example purposes)",
      "const signer = ethers.Wallet.createRandom();",
      "",
      "// get an instance of the SDK with the signer already setup",
      "const sdk = ThirdwebSDK.fromSigner(signer, \"mainnet\");"
    ],
    "description": "Get an instance of the thirdweb SDK based on an existing ethers signer | ThirdwebSDK contract"
  },
  "Get the native balance of a given address (wallet or contract) | ThirdwebSDK contract": {
    "prefix": "thirdwebsdkGetBalance",
    "body": [
      "const balance = await sdk.getBalance(\"0x...\");",
      "console.log(balance.displayValue);"
    ],
    "description": "Get the native balance of a given address (wallet or contract) | ThirdwebSDK contract"
  },
  "Get an instance of a Custom contract from a json ABI | ThirdwebSDK contract": {
    "prefix": "thirdwebsdkGetContractFromAbi",
    "body": [
      "// Import your ABI from a JSON file",
      "import myABI from \"./path/to/myABI.json\";",
      "",
      "const contract = sdk.getContractFromAbi(",
      "  \"{{contract_address}}\",",
      "  // Pass in the \"abi\" field from the JSON file",
      "  myABI.abi",
      ");"
    ],
    "description": "Get an instance of a Custom contract from a json ABI | ThirdwebSDK contract"
  },
  "Burn Tokens | Token contract": {
    "prefix": "tokenBurnFrom",
    "body": [
      "// Address of the wallet sending the tokens",
      "const holderAddress = \"{{wallet_address}}\";",
      "",
      "// The amount of this token you want to burn",
      "const amount = 1.2;",
      "",
      "await contract.burnFrom(holderAddress, amount);"
    ],
    "description": "Burn Tokens | Token contract"
  },
  "Burn Tokens | Token contract": {
    "prefix": "tokenBurnTokens",
    "body": [
      "// The amount of this token you want to burn",
      "const amount = 1.2;",
      "",
      "await contract.burnTokens(amount);"
    ],
    "description": "Burn Tokens | Token contract"
  },
  "Mint Tokens To Many Wallets | Token contract": {
    "prefix": "tokenMintBatchTo",
    "body": [
      "// Data of the tokens you want to mint",
      "const data = [",
      "  {",
      "    toAddress: \"{{wallet_address}}\", // Address to mint tokens to",
      "    amount: 0.2, // How many tokens to mint to specified address",
      "  },",
      " {",
      "   toAddress: \"0x...\",",
      "   amount: 1.4,",
      " }",
      "]",
      "",
      "await contract.mintBatchTo(data);"
    ],
    "description": "Mint Tokens To Many Wallets | Token contract"
  },
  "Mint Tokens | Token contract": {
    "prefix": "tokenMintTo",
    "body": [
      "const toAddress = \"{{wallet_address}}\"; // Address of the wallet you want to mint the tokens to",
      "const amount = \"1.5\"; // The amount of this token you want to mint",
      "",
      "await contract.mintTo(toAddress, amount);"
    ],
    "description": "Mint Tokens | Token contract"
  },
  "Get Token Allowance | Token contract": {
    "prefix": "tokenAllowance",
    "body": [
      "// Address of the wallet to check token allowance",
      "const spenderAddress = \"0x...\";",
      "const allowance = await contract.token.allowance(spenderAddress);"
    ],
    "description": "Get Token Allowance | Token contract"
  },
  "Get Token Allowance | Token contract": {
    "prefix": "tokenAllowanceOf",
    "body": [
      "// Address of the wallet who owns the funds",
      "const owner = \"{{wallet_address}}\";",
      "// Address of the wallet to check token allowance",
      "const spender = \"0x...\";",
      "const allowance = await contract.token.allowanceOf(owner, spender);"
    ],
    "description": "Get Token Allowance | Token contract"
  },
  "Get Token Balance for the currently connected wallet | Token contract": {
    "prefix": "tokenBalance",
    "body": ["const balance = await contract.token.balance();"],
    "description": "Get Token Balance for the currently connected wallet | Token contract"
  },
  "Get Token Balance | Token contract": {
    "prefix": "tokenBalanceOf",
    "body": [
      "// Address of the wallet to check token balance",
      "const walletAddress = \"{{wallet_address}}\";",
      "const balance = await contract.token.balanceOf(walletAddress);"
    ],
    "description": "Get Token Balance | Token contract"
  },
  "Get the token Metadata (name, symbol, etc...) | Token contract": {
    "prefix": "tokenGet",
    "body": ["const token = await contract.token.get();"],
    "description": "Get the token Metadata (name, symbol, etc...) | Token contract"
  },
  "Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet | Token contract": {
    "prefix": "tokenSetAllowance",
    "body": [
      "// Address of the wallet to allow transfers from",
      "const spenderAddress = \"0x...\";",
      "// The number of tokens to give as allowance",
      "const amount = 100",
      "await contract.token.setAllowance(spenderAddress, amount);"
    ],
    "description": "Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet | Token contract"
  },
  "The total supply for this Token | Token contract": {
    "prefix": "tokenTotalSupply",
    "body": ["const balance = await contract.token.totalSupply();"],
    "description": "The total supply for this Token | Token contract"
  },
  "Transfer Tokens | Token contract": {
    "prefix": "tokenTransfer",
    "body": [
      "// Address of the wallet you want to send the tokens to",
      "const toAddress = \"0x...\";",
      "// The amount of tokens you want to send",
      "const amount = 0.1;",
      "await contract.token.transfer(toAddress, amount);"
    ],
    "description": "Transfer Tokens | Token contract"
  },
  "Transfer Tokens To Many Wallets | Token contract": {
    "prefix": "tokenTransferBatch",
    "body": [
      "// Data of the tokens you want to mint",
      "const data = [",
      "  {",
      "    toAddress: \"{{wallet_address}}\", // Address to mint tokens to",
      "    amount: 100, // How many tokens to mint to specified address",
      "  },",
      " {",
      "   toAddress: \"0x...\",",
      "   amount: 100,",
      " }",
      "]",
      "",
      "await contract.token.transferBatch(data);"
    ],
    "description": "Transfer Tokens To Many Wallets | Token contract"
  },
  "Transfer Tokens From Address | Token contract": {
    "prefix": "tokenTransferFrom",
    "body": [
      "// Address of the wallet sending the tokens",
      "const fromAddress = \"{{wallet_address}}\";",
      "// Address of the wallet you want to send the tokens to",
      "const toAddress = \"0x...\";",
      "// The number of tokens you want to send",
      "const amount = 1.2",
      "// Note that the connected wallet must have approval to transfer the tokens of the fromAddress",
      "await contract.token.transferFrom(fromAddress, toAddress, amount);"
    ],
    "description": "Transfer Tokens From Address | Token contract"
  },
  "Burn Tokens | TokenDrop contract": {
    "prefix": "tokendropBurnFrom",
    "body": [
      "// Address of the wallet sending the tokens",
      "const holderAddress = \"{{wallet_address}}\";",
      "",
      "// The amount of this token you want to burn",
      "const amount = 1.2;",
      "",
      "await contract.burnFrom(holderAddress, amount);"
    ],
    "description": "Burn Tokens | TokenDrop contract"
  },
  "Burn Tokens | TokenDrop contract": {
    "prefix": "tokendropBurnTokens",
    "body": [
      "// The amount of this token you want to burn",
      "const amount = 1.2;",
      "",
      "await contract.burnTokens(amount);"
    ],
    "description": "Burn Tokens | TokenDrop contract"
  },
  "Claim a certain amount of tokens to a specific Wallet | TokenDrop contract": {
    "prefix": "tokendropClaimTo",
    "body": [
      "const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs",
      "const quantity = 42.69; // how many tokens you want to claim",
      "",
      "const tx = await contract.claimTo(address, quantity);",
      "const receipt = tx.receipt; // the transaction receipt"
    ],
    "description": "Claim a certain amount of tokens to a specific Wallet | TokenDrop contract"
  },
  "Get Token Allowance | TokenDrop contract": {
    "prefix": "tokendropAllowance",
    "body": [
      "// Address of the wallet to check token allowance",
      "const spenderAddress = \"0x...\";",
      "const allowance = await contract.token.allowance(spenderAddress);"
    ],
    "description": "Get Token Allowance | TokenDrop contract"
  },
  "Get Token Allowance | TokenDrop contract": {
    "prefix": "tokendropAllowanceOf",
    "body": [
      "// Address of the wallet who owns the funds",
      "const owner = \"{{wallet_address}}\";",
      "// Address of the wallet to check token allowance",
      "const spender = \"0x...\";",
      "const allowance = await contract.token.allowanceOf(owner, spender);"
    ],
    "description": "Get Token Allowance | TokenDrop contract"
  },
  "Get Token Balance for the currently connected wallet | TokenDrop contract": {
    "prefix": "tokendropBalance",
    "body": ["const balance = await contract.token.balance();"],
    "description": "Get Token Balance for the currently connected wallet | TokenDrop contract"
  },
  "Get Token Balance | TokenDrop contract": {
    "prefix": "tokendropBalanceOf",
    "body": [
      "// Address of the wallet to check token balance",
      "const walletAddress = \"{{wallet_address}}\";",
      "const balance = await contract.token.balanceOf(walletAddress);"
    ],
    "description": "Get Token Balance | TokenDrop contract"
  },
  "Get the token Metadata (name, symbol, etc...) | TokenDrop contract": {
    "prefix": "tokendropGet",
    "body": ["const token = await contract.token.get();"],
    "description": "Get the token Metadata (name, symbol, etc...) | TokenDrop contract"
  },
  "Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet | TokenDrop contract": {
    "prefix": "tokendropSetAllowance",
    "body": [
      "// Address of the wallet to allow transfers from",
      "const spenderAddress = \"0x...\";",
      "// The number of tokens to give as allowance",
      "const amount = 100",
      "await contract.token.setAllowance(spenderAddress, amount);"
    ],
    "description": "Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet | TokenDrop contract"
  },
  "The total supply for this Token | TokenDrop contract": {
    "prefix": "tokendropTotalSupply",
    "body": ["const balance = await contract.token.totalSupply();"],
    "description": "The total supply for this Token | TokenDrop contract"
  },
  "Transfer Tokens | TokenDrop contract": {
    "prefix": "tokendropTransfer",
    "body": [
      "// Address of the wallet you want to send the tokens to",
      "const toAddress = \"0x...\";",
      "// The amount of tokens you want to send",
      "const amount = 0.1;",
      "await contract.token.transfer(toAddress, amount);"
    ],
    "description": "Transfer Tokens | TokenDrop contract"
  },
  "Transfer Tokens To Many Wallets | TokenDrop contract": {
    "prefix": "tokendropTransferBatch",
    "body": [
      "// Data of the tokens you want to mint",
      "const data = [",
      "  {",
      "    toAddress: \"{{wallet_address}}\", // Address to mint tokens to",
      "    amount: 100, // How many tokens to mint to specified address",
      "  },",
      " {",
      "   toAddress: \"0x...\",",
      "   amount: 100,",
      " }",
      "]",
      "",
      "await contract.token.transferBatch(data);"
    ],
    "description": "Transfer Tokens To Many Wallets | TokenDrop contract"
  },
  "Transfer Tokens From Address | TokenDrop contract": {
    "prefix": "tokendropTransferFrom",
    "body": [
      "// Address of the wallet sending the tokens",
      "const fromAddress = \"{{wallet_address}}\";",
      "// Address of the wallet you want to send the tokens to",
      "const toAddress = \"0x...\";",
      "// The number of tokens you want to send",
      "const amount = 1.2",
      "// Note that the connected wallet must have approval to transfer the tokens of the fromAddress",
      "await contract.token.transferFrom(fromAddress, toAddress, amount);"
    ],
    "description": "Transfer Tokens From Address | TokenDrop contract"
  },
  "Fetch the native or ERC20 token balance of this wallet | UserWallet contract": {
    "prefix": "userwalletBalance",
    "body": [
      "// native currency balance",
      "const balance = await sdk.wallet.balance();",
      "// ERC20 token balance",
      "const erc20balance = await sdk.wallet.balance(tokenContractAddress);",
      ""
    ],
    "description": "Fetch the native or ERC20 token balance of this wallet | UserWallet contract"
  },
  "Get the currently connected address | UserWallet contract": {
    "prefix": "userwalletGetAddress",
    "body": ["const address = await sdk.wallet.getAddress();"],
    "description": "Get the currently connected address | UserWallet contract"
  },
  "Recover the signing address from a signed message | UserWallet contract": {
    "prefix": "userwalletRecoverAddress",
    "body": [
      "const message = \"Sign this message...\";",
      "const signature = await sdk.wallet.sign(message);",
      "",
      "// Now we can recover the signing address",
      "const address = sdk.wallet.recoverAddress(message, signature);"
    ],
    "description": "Recover the signing address from a signed message | UserWallet contract"
  },
  "Sign any message with the connected wallet private key | UserWallet contract": {
    "prefix": "userwalletSign",
    "body": [
      "// This is the message to be signed",
      "const message = \"Sign this message...\";",
      "",
      "// Now we can sign the message with the connected wallet",
      "const signature = await sdk.wallet.sign(message);"
    ],
    "description": "Sign any message with the connected wallet private key | UserWallet contract"
  },
  "Transfer native or ERC20 tokens from this wallet to another wallet | UserWallet contract": {
    "prefix": "userwalletTransfer",
    "body": [
      " // transfer 0.8 ETH",
      "await sdk.wallet.transfer(\"0x...\", 0.8);",
      " // transfer 0.8 tokens of `tokenContractAddress`",
      "await sdk.wallet.transfer(\"0x...\", 0.8, tokenContractAddress);"
    ],
    "description": "Transfer native or ERC20 tokens from this wallet to another wallet | UserWallet contract"
  },
  "Can Execute | Vote contract": {
    "prefix": "voteCanExecute",
    "body": [
      "// The proposal ID of the proposal you want to check",
      "const proposalId = \"0\";",
      "const canExecute = await contract.canExecute(proposalId);",
      "console.log(canExecute);"
    ],
    "description": "Can Execute | Vote contract"
  },
  "Execute Proposal | Vote contract": {
    "prefix": "voteExecute",
    "body": [
      "// The proposal ID ofthe proposal you want to execute",
      "const proposalId = \"0\"",
      "await contract.execute(proposalId);"
    ],
    "description": "Execute Proposal | Vote contract"
  },
  "Get All Proposals | Vote contract": {
    "prefix": "voteGetAll",
    "body": [
      "const proposals = await contract.getAll();",
      "console.log(proposals);"
    ],
    "description": "Get All Proposals | Vote contract"
  },
  "Check If Wallet Voted | Vote contract": {
    "prefix": "voteHasVoted",
    "body": [
      "// The proposal ID of the proposal you want to check",
      "const proposalId = \"0\";",
      "// The address of the wallet you want to check to see if they voted",
      "const address = \"{{wallet_address}}\";",
      "",
      "await contract.hasVoted(proposalId, address);"
    ],
    "description": "Check If Wallet Voted | Vote contract"
  },
  "Create Proposal | Vote contract": {
    "prefix": "votePropose",
    "body": [
      "// The description of the proposal you want to pass",
      "const description = \"This is a great proposal - vote for it!\"",
      "// You can (optionally) pass in contract calls that will get executed when the proposal is executed.",
      "const executions = [",
      "  {",
      "    // The contract you want to make a call to",
      "    toAddress: \"0x...\",",
      "    // The amount of the native currency to send in this transaction",
      "    nativeTokenValue: 0,",
      "    // Transaction data that will be executed when the proposal is executed",
      "    // This is an example transfer transaction with a token contract (which you would need to setup in code)",
      "    transactionData: tokenContract.encoder.encode(",
      "      \"transfer\", [",
      "        fromAddress,",
      "        amount,",
      "      ]",
      "    ),",
      "  }",
      "]",
      "",
      "const proposal = await contract.propose(description, executions);"
    ],
    "description": "Create Proposal | Vote contract"
  },
  "Vote | Vote contract": {
    "prefix": "voteVote",
    "body": [
      "// The proposal ID of the proposal you want to vote on",
      "const proposalId = \"0\";",
      "// The vote type you want to cast, can be VoteType.Against, VoteType.For, or VoteType.Abstain",
      "const voteType = VoteType.For;",
      "// The (optional) reason for the vote",
      "const reason = \"I like this proposal!\";",
      "",
      "await contract.vote(proposalId, voteType, reason);"
    ],
    "description": "Vote | Vote contract"
  },
  "Authenticate With Token | WalletAuthenticator contract": {
    "prefix": "walletauthenticatorAuthenticate",
    "body": [
      "const domain = \"thirdweb.com\";",
      "const loginPayload = await sdk.auth.login(domain);",
      "const token = await sdk.auth.generateAuthToken(domain, loginPayload);",
      "",
      "// Authenticate the token and get the address of authenticating users wallet",
      "const address = sdk.auth.authenticate(domain, token);"
    ],
    "description": "Authenticate With Token | WalletAuthenticator contract"
  },
  "Generate Authentication Token | WalletAuthenticator contract": {
    "prefix": "walletauthenticatorGenerateAuthToken",
    "body": [
      "const domain = \"thirdweb.com\";",
      "const loginPayload = await sdk.auth.login(domain);",
      "",
      "// Generate a JWT token that can be sent to the client-side wallet and used for authentication",
      "const token = await sdk.auth.generateAuthToken(domain, loginPayload);"
    ],
    "description": "Generate Authentication Token | WalletAuthenticator contract"
  },
  "Login With Connected Wallet | WalletAuthenticator contract": {
    "prefix": "walletauthenticatorLogin",
    "body": [
      "// Add the domain of the application users will login to, this will be used throughout the login process",
      "const domain = \"thirdweb.com\";",
      "// Generate a signed login payload for the connected wallet to authenticate with",
      "const loginPayload = await sdk.auth.login(domain);"
    ],
    "description": "Login With Connected Wallet | WalletAuthenticator contract"
  },
  "Verify Logged In Address | WalletAuthenticator contract": {
    "prefix": "walletauthenticatorVerify",
    "body": [
      "const domain = \"thirdweb.com\";",
      "const loginPayload = await sdk.auth.login(domain);",
      "",
      "// Verify the login request",
      "const address = sdk.auth.verify(domain, loginPayload);"
    ],
    "description": "Verify Logged In Address | WalletAuthenticator contract"
  }
}
